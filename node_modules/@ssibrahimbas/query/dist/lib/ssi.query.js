"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = exports.SsiQuery = void 0;
require("./util/string.util");
class SsiQuery {
    constructor() {
        this._select = "*";
        this._from = null;
        this._where = null;
        this._limit = null;
        this._offset = null;
        this._join = null;
        this._orderBy = null;
        this._groupBy = null;
        this._having = null;
        this._grouped = null;
        this._query = null;
        this._prefix = "";
        this._operators = ["=", "!=", "<", ">", "<=", ">=", "<>"];
        this.parseSelectWithAsObject = (obj) => {
            return Object.entries(obj)
                .map(([key, value]) => `${key} AS ${value}`)
                .join(", ");
        };
    }
    table(table) {
        if (table instanceof Array) {
            let from = "";
            for (const field of table) {
                from += this._prefix + field + ", ";
            }
            this._from = from.rtrim(", ");
        }
        else {
            if (table.includes(",")) {
                const tables = table
                    .split(",")
                    .map((t) => this._prefix + t.ltrim());
                this._from = tables.join(", ");
            }
            else {
                this._from = this._prefix + table;
            }
        }
        return this;
    }
    select(fields) {
        let _fields = "";
        if (fields instanceof Array && fields.length > 0) {
            if (typeof fields[0] !== "string") {
                fields.forEach((field) => {
                    if (_fields.length > 1) {
                        _fields += ", ";
                    }
                    _fields += this.parseSelectWithAsObject(field);
                });
            }
            else {
                _fields = fields.join(", ");
            }
        }
        else if (typeof fields !== "string") {
            _fields = this.parseSelectWithAsObject(fields);
        }
        else {
            _fields = fields;
        }
        this.optimizeSelect(_fields);
        return this;
    }
    groupConcat(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("GROUP_CONCAT", fields, name));
        return this;
    }
    least(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("LEAST", fields.join(","), name));
        return this;
    }
    max(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("MAX", fields, name));
        return this;
    }
    min(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("MIN", fields, name));
        return this;
    }
    sum(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("SUM", fields, name));
        return this;
    }
    count(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("COUNT", fields, name));
        return this;
    }
    avg(fields, name) {
        this.optimizeSelect(this.optimizeSqlFunctionWithPlaceholder("AVG", fields, name));
        return this;
    }
    join(table, field1 = null, operator = null, field2 = null, type = "") {
        let on = field1;
        let _table = this._prefix + table;
        if (operator !== null) {
            if (!this._operators.includes(operator)) {
                on = `${field1} = ${operator}${field2 !== null ? field2 : ""}`;
            }
            else {
                on = `${field1} ${operator} ${field2}`;
            }
        }
        this._join =
            this._join === null
                ? ` ${type} JOIN ${_table} ON ${on}`
                : `${this._join} ${type} JOIN ${_table} ON ${on}`;
        return this;
    }
    innerJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "INNER");
    }
    leftJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "LEFT");
    }
    rightJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "RIGHT");
    }
    fullOuterJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "FULL OUTER");
    }
    leftOuterJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "LEFT OUTER");
    }
    rightOuterJoin(table, field1, operator = "", field2 = "") {
        return this.join(table, field1, operator, field2, "RIGHT OUTER");
    }
    where(where, operator = null, val = null, type = "", andOr = "AND") {
        if (where instanceof Array && where.length !== 0) {
            let _where = where.map((w, index) => type + index + "=" + this.escape(w));
            where = _where.join(` ${andOr} `);
        }
        else {
            if (where === null || where.length === 0 || typeof where !== "string")
                return this;
            if (operator instanceof Array) {
                let params = where.split("?");
                let _where = "";
                params.forEach((param, index) => {
                    if (!!!param)
                        return;
                    _where +=
                        type +
                            param +
                            (!!operator[index] ? this.escape(operator[index]) : "");
                });
                where = _where;
            }
            else if ((typeof operator === "string" && !this._operators.includes(operator)) ||
                operator === false) {
                where = type + where + " = " + this.escape(operator);
            }
            else {
                where = type + where + " " + operator + " " + this.escape(val);
            }
        }
        this.setWhereGrouped(where, andOr);
        return this;
    }
    orWhere(where, operator = null, val = null) {
        return this.where(where, operator, val, "", "OR");
    }
    notWhere(where, operator = null, val = null) {
        return this.where(where, operator, val, "NOT ", "AND");
    }
    orNotWhere(where, operator = null, val = null) {
        return this.where(where, operator, val, "NOT ", "OR");
    }
    whereNull(where, not = false) {
        where = `${where} IS ${not ? "NOT " : ""}NULL`;
        this.setWhere(where, "AND");
        return this;
    }
    whereNotNull(where) {
        return this.whereNull(where, true);
    }
    grouped(callback) {
        this._grouped = true;
        callback(this);
        this._where += ")";
        return this;
    }
    in(field, keys, type = "", andOr = "AND") {
        if (keys instanceof Array) {
            keys = keys.map((k) => this.escape(k));
            let _where = field + " " + type + "IN (" + keys.join(", ") + ")";
            this.setWhereGrouped(_where, andOr);
        }
        return this;
    }
    notIn(field, keys) {
        return this.in(field, keys, "NOT ", "AND");
    }
    orIn(field, keys) {
        return this.in(field, keys, "", "OR");
    }
    orNotIn(field, keys) {
        return this.in(field, keys, "NOT ", "OR");
    }
    findInSet(field, key, type = "", andOr = "AND") {
        key = typeof key === "string" ? this.escape(key) : key;
        let _where = type + "FIND_IN_SET (" + key + ", " + field + ")";
        this.setWhereGrouped(_where, andOr);
        return this;
    }
    notFindInSet(field, key) {
        return this.findInSet(field, key, "NOT ");
    }
    orFindInSet(field, key) {
        return this.findInSet(field, key, "", "OR");
    }
    orNotFindInSet(field, key) {
        return this.findInSet(field, key, "NOT ", "OR");
    }
    between(field, value1, value2, type = "", andOr = "AND") {
        let where = "(" +
            field +
            " " +
            type +
            "BETWEEN " +
            this.escape(value1) +
            " AND " +
            this.escape(value2) +
            ")";
        this.setWhereGrouped(where, andOr);
        return this;
    }
    notBetween(field, value1, value2) {
        return this.between(field, value1, value2, "NOT ", "AND");
    }
    orBetween(field, value1, value2) {
        return this.between(field, value1, value2, "", "OR");
    }
    orNotBetween(field, value1, value2) {
        return this.between(field, value1, value2, "NOT ", "OR");
    }
    like(field, data, type = "", andOr = "AND") {
        let like = this.escape(data);
        let where = field + " " + type + "LIKE " + like;
        this.setWhereGrouped(where, andOr);
        return this;
    }
    orLike(field, data) {
        return this.like(field, data, "", "OR");
    }
    notLike(field, data) {
        return this.like(field, data, "NOT ");
    }
    orNotLike(field, data) {
        return this.like(field, data, "NOT ", "OR");
    }
    limit(limit, limitEnd = null) {
        this._limit = limitEnd !== null ? limit + ", " + limitEnd : limit;
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    pagination(perPage, page) {
        this._limit = perPage;
        this._offset = (page > 0 ? page : 1) * perPage;
        return this;
    }
    orderBy(orderBy, orderDir = null) {
        if (orderDir !== null) {
            this._orderBy = orderBy + " " + orderDir.toUpperCase();
        }
        else {
            this._orderBy =
                orderBy.slice(orderBy.indexOf(" "), orderBy.length - 1) ||
                    orderBy.toLowerCase() === "rand()"
                    ? orderBy
                    : orderBy + " ASC";
        }
        return this;
    }
    groupBy(groupBy) {
        this._groupBy = groupBy instanceof Array ? groupBy.join(", ") : groupBy;
        return this;
    }
    having(field, operator = null, val = null) {
        if (operator instanceof Array) {
            let fields = field.split("?");
            let where = "";
            fields.forEach((field, index) => {
                if (field) {
                    where +=
                        field + (!!operator[index] ? this.escape(operator[index]) : "");
                }
            });
            this._having = where;
        }
        else if (!this._operators.includes(operator)) {
            this._having = field + " > " + this.escape(operator);
        }
        else {
            this._having = field + " " + operator + " " + this.escape(val);
        }
        return this;
    }
    get() {
        this._limit = 1;
        return this.getAll();
    }
    getAll() {
        let query = "SELECT " + this._select + " FROM " + this._from;
        if (this._join !== null) {
            query += this._join;
        }
        if (this._where !== null) {
            query += " WHERE " + this._where;
        }
        if (this._groupBy !== null) {
            query += " GROUP BY " + this._groupBy;
        }
        if (this._having !== null) {
            query += " HAVING " + this._having;
        }
        if (this._orderBy !== null) {
            query += " ORDER BY " + this._orderBy;
        }
        if (this._limit !== null) {
            query += " LIMIT " + this._limit;
        }
        if (this._offset !== null) {
            query += " OFFSET " + this._offset;
        }
        this.reset();
        return query;
    }
    insert(data) {
        let query = "INSERT INTO " + this._from;
        let values = Object.values(data);
        if (!!values[0] && typeof values[0] === "object") {
            let col = Object.keys(values[0]).join(", ");
            query += " (" + col + ") VALUES ";
            for (const value of values) {
                let val = value.map((v) => this.escape(v)).join(", ");
                query += "(" + val + "), ";
            }
            query = query.trim("), ");
        }
        else {
            let col = Object.keys(data).join(", ");
            let val = values.map((v) => this.escape(v)).join(", ");
            query += " (" + col + ") VALUES (" + val + ")";
        }
        this.reset();
        return query;
    }
    update(data) {
        let query = "UPDATE " + this._from + " SET ";
        let values = Object.entries(data).map(([key, value]) => key + "=" + this.escape(value));
        query += values.join(", ");
        query = this.updateQueryForUpdateAndDeleteQueries(query);
        this.reset();
        return query;
    }
    delete() {
        let query = "DELETE FROM " + this._from;
        let initialQuery = query;
        query = this.updateQueryForUpdateAndDeleteQueries(query);
        if (query === initialQuery) {
            query += "TRUNCATE TABLE " + this._from;
        }
        this.reset();
        return query;
    }
    analyze() {
        this.query("ANALYZE TABLE " + this._from);
        return this._query;
    }
    check() {
        this.query("CHECK TABLE " + this._from);
        return this._query;
    }
    checksum() {
        this.query("CHECKSUM TABLE " + this._from);
        return this._query;
    }
    optimize() {
        this.query("OPTIMIZE TABLE " + this._from);
        return this._query;
    }
    repair() {
        this.query("REPAIR TABLE " + this._from);
        return this._query;
    }
    query(query, values = null) {
        this.reset();
        if (values === null) {
            this._query = query;
            return this;
        }
        let params = query.split("?");
        let _query = "";
        params.forEach((param, index) => {
            if (!!param) {
                _query += param + this.escape(values[index]);
            }
        });
        this._query = _query;
        return this;
    }
    reset() {
        this._select = "*";
        this._from = null;
        this._where = null;
        this._limit = null;
        this._offset = null;
        this._join = null;
        this._orderBy = null;
        this._groupBy = null;
        this._having = null;
        this._grouped = null;
        this._query = null;
        this._prefix = "";
    }
    getQuery() {
        return this._query;
    }
    setWhere(where, andOr) {
        this._where =
            this._where === null ? where : this._where + " " + andOr + " " + where;
    }
    setWhereGrouped(where, andOr) {
        if (this._grouped) {
            where = "(" + where;
            this._grouped = false;
        }
        this.setWhere(where, andOr);
    }
    optimizeSelect(fields) {
        this._select = this._select === "*" ? fields : this._select + ", " + fields;
    }
    optimizeSqlFunctionWithPlaceholder(funcName, fields, name) {
        return `${funcName}(${fields})${name !== null ? " AS " + name : ""}`;
    }
    escape(data) {
        if (data === null)
            return "NULL";
        if (typeof data === "number")
            data.toString();
        return `'${data}'`;
    }
    updateQueryForUpdateAndDeleteQueries(query) {
        if (this._where !== null) {
            query += " WHERE " + this._where;
        }
        if (this._orderBy !== null) {
            query += " ORDER BY " + this._orderBy;
        }
        if (this._limit !== null) {
            query += " LIMIT " + this._limit;
        }
        return query;
    }
}
exports.SsiQuery = SsiQuery;
exports.Query = new SsiQuery();
